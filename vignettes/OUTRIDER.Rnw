%\VignetteIndexEntry{OUTRIDER: OUTlier in RNA-seq fInDER}
%\VignettePackage{OUTRIDER}
%\VignetteEngine{knitr::knitr}
%\VignetteEncoding{UTF-8}

\documentclass[11pt]{article}

<<style-knitr, eval=TRUE, echo=FALSE, results="asis">>=
BiocStyle::latex()
@

<<knitr, echo=FALSE, cache=FALSE, results="hide">>=
library(knitr)
opts_chunk$set(
    tidy=FALSE,
    dev="png",
    fig.width=7,
    fig.height=7,
    dpi=300,
    message=FALSE,
    warning=FALSE,
    cache=FALSE
)
@

\usepackage{amsmath}
\usepackage{verbatim}
\usepackage[nottoc]{tocbibind}

\newcommand{\outrider}{\Biocpkg{OUTRIDER}}
\newcommand{\rna}{RNA-seq}
\newcommand{\deseq}{\Biocpkg{DESeq2}}
\newcommand{\ods}{\Rclass{OutriderDataSet}}

\title{OUTRIDER - OUTlier in RNA-Seq fInDER}

\author{
    Felix Brechtmann$^{1}$, Christian Mertes$^{1}$, Agne Matuseviciute$^{1}$, 
        Vicente Yepez$^{1}$, Julien Gagneur$^{1}$ \\
    \small{$^{1}$ Technische Universit\"at M\"unchen, Department of 
        Informatics, Garching, Germany}
}

\begin{document}

<<include=FALSE>>=
opts_chunk$set(concordance=TRUE)
@

\maketitle

\begin{abstract}

In the field of diagnostics of rare diseases, \rna{} is emerging as an 
important and complementary tool for whole exome and whole genome sequencing. 
\outrider{} is a framework that detects aberrant gene expression within a 
group of samples. It uses the negative binomial distribution which is fitted 
for each gene over all samples. We additionally provide an autoencoder, 
which automatically controls for co-variation before fitting. After fitting,
each sample can be tested for aberrantly expressed genes. Furthermore,
\outrider{} provides methods to easily filter unexpressed genes and to 
analyse as well as to visualize the results.

\vspace{3em}

\begin{center}
\begin{tabular}{ | l | }
\hline
If you use \outrider{} in published research, please cite:  \\
\\
Brechtmann F*, Matuseviciute A*, Mertes C*, Yepez V, Avsec Z, Herzog M, \\
Bader D M, Prokisch H, Gagneur J; \textbf{OUTRIDER: A statistical method} \\
\textbf{for detecting aberrantly expressed genes in RNA sequencing data}; \\
\emph{bioRxiv}; 2018 \\
\hline
\end{tabular}
\end{center}

\end{abstract}

\newpage

\tableofcontents

\newpage


<<hiden_config, echo=FALSE, cache=FALSE>>=
suppressPackageStartupMessages({
    library(OUTRIDER)
    library(beeswarm)
})
if(multicoreWorkers() >= 4){
    register(MulticoreParam(min(6, multicoreWorkers())))
} else {
    register(SerialParam())
}
@

\section{Introduction}
\outrider{} (OUTlier in RNA-seq fInDER) is a tool to find aberrantly expressed
genes in RNA-seq samples. It does so by fitting a negative binomial model 
to RNA-seq read counts, correcting for variations in sequencing depth and 
apparent co-variations across samples. Read counts significantly deviating 
from the distribution are detected as outliers. \outrider{} makes use of an
autoencoder to control automatically for confounders within the data. A scheme
of this approach is given in Figure \ref{fig:Autencoder}.


\begin{figure}
    \includegraphics[width=0.8\textwidth]{autoencoder_sketch.png}
    \caption{Context-dependent outlier detection. The algorithm identifies gene expression outliers whose read counts are significantly aberrant given the co-variations typically observed across genes in an RNA sequencing data set. This is illustrated by a read count (left panel, fifth column, second row from the bottom) that is exceptionally high in the context of correlated samples (left six samples) but not in absolute terms for this given gene. To capture commonly seen biological and technical contexts, an autoencoder models co-variations in an unsupervised fashion and predicts read count expectations. By comparing the earlier mentioned read count with these context-dependent expectations, it is revealed as exceptionally high (right panel). The lower panels illustrate the distribution of read counts before and after applying the correction for the relevant gene. The red dotted lines depict significance cutoffs.}
    \label{fig:Autoencoder}
\end{figure}



Differential gene expression analysis from RNA-seq data is well-established.
The packages \deseq{}\cite{Love2014} or \Biocpkg{edgeR}\cite{Robinson2010} 
provide effective workflows and preprocessing steps to perform differential gene
expression analysis. However, these methods aim at detecting significant 
differences between groups of samples. In contrast, \outrider{} aims at 
detecting outliers within a given population. A scheme of this difference is 
given in figure \ref{fig:deVsOutlier}.

<<deVsOutlier, echo=FALSE, fig.height=5, fig.cap="Scheme of workflow differences. Differences between differential gene expression analysis and outlier detection.">>=
par.old <- par(no.readonly=TRUE)
par(mfrow=c(1,2), cex=1.2)
ylim <- c(80, 310)
a <- rnorm(10, 250, 10)
b <- rnorm(10, 120, 10)
c <- rnorm(100, 250, 20)
c[1] <- 105
beeswarm(list(A=a, B=b), main="Differential expression\nanalysis",
     xlab="Condition", ylab="Expression", ylim=ylim, pch=20, 
     col=c("darkblue", "firebrick"))
beeswarm(c, main="Outlier detection", ylim=ylim, pch=20, 
    xlab="Population", ylab="Expression", col="firebrick")

par(par.old)
@

\section{Prerequisites}
To get started on the preprocessing step, we recommend to read the 
introductions of the aforementioned tools or the RNA-seq workflow from
Bioconductor. In brief, one usually starts with the raw FASTQ files from
the RNA sequencing run. Those are then aligned to a given reference genome. As 
of now (June 2018), we recommend the STAR aligner\cite{Dobin2013}. After 
obtaining the aligned BAM files, one can map the reads to exons or genes of a 
GTF annotation file using HT-seq. The resulting count table can then be loaded 
into the \outrider{} package as we will describe below.

\section{A quick tour}

Here we assume that we already have a count table and no additional 
preprocessing needs to be done. Then we can start and obtain results with 
3 commands. First, create an \ods{} from a count table. Second, run the full 
pipeline using the command \Rfunction{OUTRIDER}. In the third and last step the 
results table is extracted from the \ods{} with the \Rfunction{results} 
function. Furthermore, analysis plots that are described in section 
\ref{sec:Results} can be directly created from the \ods{} object.

<<quick_guide, fig.height=5>>=
library(OUTRIDER)

# get data
ctsFile <- system.file('extdata', 'KremerNBaderSmall.tsv', 
        package='OUTRIDER')
ctsTable <- read.table(ctsFile, check.names=FALSE)
ods <- OutriderDataSet(countData=ctsTable)

# filter out non expressed genes
ods <- filterExpression(ods, minCounts=TRUE, filterGenes=TRUE)

# run full OUTRIDER pipeline (control, fit model, calculate P-values)
ods <- OUTRIDER(ods)

# results (only significant)
res <- results(ods)
head(res)

# example of a Q-Q plot for the most significant outlier
plotQQ(ods, res[1, geneID])
@

\section{An \outrider{} analysis in detail}

Additionally to the single wrapper function \Rfunction{OUTRIDER} to run the full 
pipeline, the analysis can also be run step by step. The wrapper function does
not include any preprocessing functions, discarding non expressed genes or 
samples failing quality measurements should be done manually before running the 
\Rfunction{OUTRIDER} function or starting the analysis pipeline.

In this section we will explain the analysis functions step by step.

For this tutorial we will use the rare disease data set from Kremer 
\textit{et al}.\cite{Kremer2017} For testing, this package contains also a small
subset of it.

<<GetDataSet>>=
URL <- paste0("https://media.nature.com/original/nature-assets/", 
        "ncomms/2017/170612/ncomms15824/extref/ncomms15824-s1.txt")
ctsTable <- read.table(URL, sep="\t")

# create OutriderDataSet object
ods <- OutriderDataSet(countData=ctsTable)
@

\subsection{Preprocessing}

It is recommended to apply some data preprocessing before fitting. Our model 
requires that for every gene at least one sample has one read (counts > 0) and 
that we observe one read every 100 samples. Therefore, all genes that are not 
expressed must be discarded.

We provide the function \Rfunction{filterExpression} to remove genes that have 
low FPKM (Fragments Per Kilobase of transcript per Million mapped reads) 
expression values. The needed annotation to estimate FPKM values 
from the counts should be the same as for the counting. Here, we normalize 
by the total exon length of a gene.

By default the cutoff is set to an FPKM value of one and only the filtered
\ods{} object is returned. If required, the FPKM values can be stored in the
\ods{} object and the full object can be returned to visualize the 
distribution of reads before and after filtering. 

<<Preprocessing, fig.height=5>>=
# get annotation
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(org.Hs.eg.db)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
map <- select(org.Hs.eg.db, keys=keys(txdb, keytype = "GENEID"), 
        keytype="ENTREZID", columns=c("SYMBOL"))
@

The \Robject{TxDb.Hsapiens.UCSC.hg19.knownGene} contains only well annotated 
genes. This annotation will miss a lot of genes captured by RNA-seq. To include 
all predicted annotations as well as non-coding RNAs please download the txdb 
object from our homepage\footnote{\url{https://i12g-gagneurweb.in.tum.de/public/paper/mitoMultiOmics/ucsc.knownGenes.db}}
or create it yourself from the UCSC website\footnote{\url{https://genome.ucsc.edu/cgi-bin/hgTables}}$^,$\footnote{\url{http://genomewiki.ucsc.edu/index.php/Genes_in_gtf_or_gff_format}}.

<<create txdb, eval=FALSE, cache=FALSE>>=
library(RMySQL)
library(AnnotationDbi)
txdbUrl <- paste0("https://i12g-gagneurweb.in.tum.de/public/",
        "paper/mitoMultiOmics/ucsc.knownGenes.db")
download.file(txdbUrl, "ucsc.knownGenes.db")
txdb <- loadDb("ucsc.knownGenes.db")
con <- dbConnect(MySQL(), host='genome-mysql.cse.ucsc.edu', 
        dbname="hg19", user='genome')
map <- dbGetQuery(con, 'select kgId AS TXNAME, geneSymbol from kgXref')

@

<<filtering, fig.height=5>>=
# calculate FPKM values and label not expressed genes
ods <- filterExpression(ods, txdb, mapping=map, 
        filterGenes=FALSE, savefpkm=TRUE)

# display the FPKM distribution of counts.
plotFPKM(ods)

# do the actual subsetting based on the filtering labels
ods <- ods[mcols(ods)$passedFilter,]
@

\subsection{Controlling for Confounders}

A next step in any analysis workflow is to visualize the correlations
between samples. In most RNA-seq experiments correlations between the samples 
can be observed, which are often due to confounders: technical ones like the 
sequencing batch or biological ones like sex. These confounders can harm the 
detection of aberrant features. Therefore, we provide options to control for 
them.

<<plotting_between_sample_correlations>>=

# Heatmap of the sample correlation
# it can also annotate the clusters resulting from the dendrogram
ods <- plotCountCorHeatmap(ods, normalized=FALSE, nCluster=4)

@

We have different ways to control for confounders present in the data.
The first and standard way is to calculate the \Rfunction{sizeFactors} 
as done in \deseq{}\cite{Love2014}.

Additionally, the \Rfunction{autoCorrect} function calls an 
autoencoder that automatically controls for confounders present in the data.
Therefore an encoding dimension $q$ needs to be set or the default value 20 is 
used. The optimal value of $q$ can be determinde using the
\Rfunction{findEncodingDim} function. 
After controlling for confounders, the heatmap should be plotted again.
If it worked, no batches should be present and the correlations between 
samples should be reduced and close to zero.

<<controlling_for_confounders>>=

# automatically control for confounders 
ods <- estimateSizeFactors(ods)
ods <- controlForConfounders(ods, q=21)

# Heatmap of the sample correlation after controlling
ods <- plotCountCorHeatmap(ods, normalized=TRUE)

@

Alternatively, a \Rfunction{normalizationFactor} matrix can be provided. 
It must be computed beforehand using any method. Its purpose is to normalize
for technical effects or control for additional expression patterns.

\subsection{Fitting the negative binomial model}

The fit of the model is done during the autoencoder fitting. This step is only
needed if alternative methods to control the data is are used.
To fit the dispersion and the mean, the \Rfunction{fit} function is applied
to the \ods{}.

<<fitting>>=
# plot dispersion versus mean counts 
#plotDispEsts(ods)
@

\subsection{P-value calculation}

After determining the fit parameters, two-sided P-values are computed using 
the following equation:

\begin{equation}
    p_{ij} = 2 \cdot min \left\{\frac{1}{2}, \sum_{0}^{k_{ij}} 
        NB(\mu_{ij} ,\theta_i), 1 - \sum_{0}^{k_{ij-1}} 
        NB(\mu_{ij} ,\theta_i) \right\},
\end{equation}

where the $\frac{1}{2}$ term handles the case of both terms exceeding 0.5, 
which can happen due to the discrete nature of counts. Here $\mu_{ij}$ are 
computed as the product of the fitted correction values from the autoencoder and
the fitted mean adjustements. If required a one-sided test can be performed 
using the argument \Robject{alternative} and specifying 'less' or 'greater' 
depending on the research question. Multiple testing correction is done across 
all genes in a per-sample fashion using Benjamini-Yekutieli's false discovery 
rate method\cite{Benjamini2001}. Alternatively, all adjustment methods supported
by \Rfunction{p.adjust} can be used via the \Robject{method} 
argument.

<<pValue_computation>>=
# compute P-values (nominal and adjusted)
ods <- computePvalues(ods, alternative="two.sided", method="BY")
@

\subsection{Z-score calculation}
The Z-scores on the log transformed counts can be used for visualization,
filtering, and ranking of samples. By running the \Rfunction{computeZscores}
function, the Z-scores are computed and stored in the \ods{} object.
The Z-scores are calculated using:

\begin{equation}
    z_{ij} = \frac{l_{ij} - \mu_j^l}{\sigma_j^l}
\end{equation}
\begin{equation*}
    l_{ij} = \log_2{(\frac{k_{ij} + 1}{c_{ij}})},
\end{equation*}

where $\mu_j^l$ is the mean and $\sigma_j^l$ the 
standard deviation of gene $j$ and $l_{ij}$ is the log 
transformed count after correction for confounders.

<<zScore_computation>>=
# compute the Z-scores
ods <- computeZscores(ods)
@

\section{Results}
\label{sec:Results}
The \outrider{} package offers multiple ways to display the results. It 
creates a results table containing all the values computed during the analysis.
Furthermore, it offers various plot functions that guide the user 
through the analysis.

\subsection{Results table}

The \Rfunction{results} function gathers all the previously computed values
and combines them into one table.

<<results fun>>=
# get results (default only significant, padj < 0.05)
res <- results(ods)
head(res)
dim(res)

# setting a different significance level and filtering by Z-scores
res <- results(ods, padjCutoff=0.1, zScoreCutoff=2)
head(res)
dim(res)
@


\subsection{Number of aberrant genes per sample}

One quantity of interest is the number of aberrantly expressed genes 
per sample. This can be displayed using the plotting function 
\Rfunction{plotAberrantPerSample}. Alternatively, the function 
\Rfunction{aberrant} can be used to identify aberrant events, which can be 
summed by sample or gene using the paramter \Robject{by}. These numbers depend 
on the cutoffs, which can be specified in both functions (\Robject{padjCutoff} 
and \Robject{zScoreCutoff}).

<<aberrantperSample, fig.height=5>>=
# number of aberrant genes per sample
tail(sort(aberrant(ods, by="sample")))
tail(sort(aberrant(ods, by="gene", zScoreCutoff=1)))

# plot the aberrant events per sample
plotAberrantPerSample(ods, padjCutoff=0.05)
@

\subsection{Volcano plots}

To view the distribution of P-values on a sample level, volcano plots can 
be displayed. Most of the plots make use of the \CRANpkg{plotly} 
framework to create interactive plots. For this vignette, we will always use 
the basic R functionality from \CRANpkg{graphics} by setting the argument 
\Rcode{basePlot} to \Rcode{TRUE}.

<<volcano, fig.height=5>>=
# MUC1344 is a diagnosed sample from Kremer et al.
plotVolcano(ods, "MUC1344", basePlot=TRUE)
@


\subsection{Gene level plots}

Additionally, we include two plots at the gene level. 
\Rfunction{plotExpressionRank} plots the counts in ascending order. 
By default, the controlled counts are plotted. To plot raw counts, the argument 
\Robject{normalized} can be set to \Rcode{FALSE}. 

When using the \CRANpkg{plotly} framework for plotting, all computed values 
are displayed for each data point. The user can access this information 
by hovering over each data point with the mouse.

<<visualization2, fig.height=5>>=
# expression rank of a gene with outlier events
plotExpressionRank(ods, "TIMMDC1", basePlot=TRUE)
@

The quantile-quantile plot can be used to see whether the fit converged well.
In presence of an outlier, it can happen that most of the points end up below 
the confidence band. This is fine and indicates that we have conservative 
P-values for the other points. Here is an example with two outliers:

<<visualization3, fig.height=5>>=
## QQ-plot for a given gene
plotQQ(ods, "TIMMDC1")
@


\section{Details}

We provide the \Rfunction{plotPowerAnalysis} function to show, what kind of 
changes can be significant depending on the mean count.
<<visualizationSigLevels, fig.height=5>>=
## P-values versus Mean Count
plotPowerAnalysis(ods)
@
Here, we see that it is only for sufficiently high expressed genes possible, to 
obtain significant P-values, especially for the downregulation cases.

\bibliography{bibliography}

\section*{Session info}

Here is the output of \Rfunction{sessionInfo()} on the system on which 
this document was compiled:

<<sessionInfo, echo=FALSE>>=
sessionInfo()
@

\end{document}
